use anyhow::Result;
use std::fs;
use std::path::Path;

/// Defines how the new content should be written to the .gitignore file.
#[derive(Debug, Clone, Copy)]
pub enum WriteMode {
    /// Append to the end of the existing file (with a backup).
    Append,
    /// Replace the existing file entirely (with a backup).
    Overwrite,
}

/// Writes the selected template content to a .gitignore file in the current directory.
/// Always creates a .gitignore.bak if an existing file is modified or overwritten.
pub fn write_gitignore(content: &str, mode: WriteMode) -> Result<()> {
    let path = Path::new(".gitignore");

    match mode {
        WriteMode::Append if path.exists() => {
            let backup_path = Path::new(".gitignore.bak");
            fs::copy(path, backup_path)?;

            let existing = fs::read_to_string(path)?;
            let mut new_content = existing;

            if !new_content.ends_with('\n') && !new_content.is_empty() {
                new_content.push('\n');
            }

            new_content.push_str("\n# --- Added by autogitignore ---\n");
            new_content.push_str(content);
            new_content.push('\n');

            fs::write(path, new_content)?;
        }
        _ => {
            // Overwrite OR path doesn't exist
            if path.exists() {
                let backup_path = Path::new(".gitignore.bak");
                fs::copy(path, backup_path)?;
            }
            let mut new_content = String::from("# .gitignore generated by autogitignore\n\n");
            new_content.push_str(content);
            new_content.push('\n');
            fs::write(path, new_content)?;
        }
    }

    Ok(())
}
